#### 创建分支

​		一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点：

![img](分支.assets/925240-20160423170116366-1271622497.png)

​		当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上：

![img](分支.assets/925240-20160423171901538-103030485.png)

​	

```bash
git branch <branch_name>   #创建指定名称的分支 
git checkout -b <branch_name>  #创建指定名称的分支，并切换
```

  

查看分支

​		Git创建一个分支很快，因为除了增加一个`dev`指针，改改`HEAD`的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：

![img](分支.assets/925240-20160423172106413-2099839645.png)

```bash
git branch #查看所有分支，* 号代表当前工作分支
git branch -v #查看分支详情，包括分支指向的commitId及提交信息
```



合并分支

​		假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：

![img](分支.assets/925240-20160423172212929-611975577.png)

​		所以Git合并分支也很快！就改改指针，工作区内容也不变！	

```bash
git merge <branch_name> #将指定分支合并到当前分支
```

​		如果两个分支没有产生分叉情况，那么会进行快速合并，即`fast-forward`方式，它并不会产生新的commitId，只是改变了指针的指向(即上图所示)，产生分叉合并可能会有冲突情况。

```bash
git merge --no-ff -m "msg" <branch_name> #合并分支时禁用Fast forward模式
```

​		我们知道如果使用`fast-forward`方式进行分支合并，只是简单改变了分支指针，而不会产生新的`commit`记录。

​		为了保证合并数据的完整性，我们也可以在合并时指定不使用`fast-forward`方式，使用 `--no-ff` 选项。这样，在`merge`时就会生成一个新的commit，从日志上就可以看到分支合并记录了。



删除分支

​		合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：

![img](分支.assets/925240-20160423172333538-1672105116.png)

```bash
git branch -d <branch_name>	#删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录)
git branch -D <branch_name> #强制删除一个分支，不管该分支有没有合并到当前分支的提交记录
```

**注意：**删除分支前都需要先切换到其他分支才能进行删除操作



解决冲突

​		准备新的`feature1`分支，修改readme.txt最后一行

​		切换到`master`分支，在`master`分支上修改readme.txt文件的最后一行

​		现在，`master`分支和`feature1`分支各自都分别有新的提交，变成了这样：

![img](分支.assets/925240-20160423183358601-286358803.png)

这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来

